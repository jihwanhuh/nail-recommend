# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16N-jVvq9oB95AcEnhG3rB0525Kvrm9QB
"""

import numpy as np
import cv2
import pandas as pd
import torch
from ultralytics import YOLO
from segment_anything_hq import sam_model_registry, SamPredictor
from PIL import Image

# ë‹¤ìš´ë¡œë“œ sam_hq_vit_h.pth
# !wget -O /content/sam_hq_vit_h.pth https://huggingface.co/lkeab/hq-sam/resolve/main/sam_hq_vit_h.pth

# ---------- ê²½ë¡œ ì„¤ì • ----------
YOLO_MODEL_PATH = "../02_nail_seg_yolo/best.pt"
SAM_CHECKPOINT_PATH = "sam_hq_vit_h.pth" #
DESIGN_CSV_PATH = "../01_data_text_rule/basic_data/04_group_shape_design_rule.csv"

# PNG í•©ì„±ìš© ë””ë ‰í† ë¦¬
PNG_DIR = "../04_pt_video"   # PNGë“¤ì„ ì €ì¥í•˜ëŠ” í´ë” (ì˜ˆ: oval_glitter.png)


# ---------- ì¶”ì²œ í…Œì´ë¸” ë¡œë“œ ----------
design_df = pd.read_csv(DESIGN_CSV_PATH)

# ---------- ëª¨ë¸ ë¡œë“œ ----------
device = "cuda" if torch.cuda.is_available() else "cpu"

yolo_model = YOLO(YOLO_MODEL_PATH)

sam = sam_model_registry["vit_h"](checkpoint=SAM_CHECKPOINT_PATH)
sam.to(device)
predictor = SamPredictor(sam)



# ===========================================================
# 1) ë§ˆìŠ¤í¬ì—ì„œ ì†í†± ê¸¸ì´/í­ ë¶„ì„
# ===========================================================
def analyze_shape_from_mask(mask: np.ndarray):

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                   cv2.CHAIN_APPROX_SIMPLE)
    if len(contours) == 0:
        return [], None

    contours = sorted(contours, key=lambda c: cv2.boundingRect(c)[0])

    widths = [cv2.boundingRect(c)[2] for c in contours]
    width_median = np.median(widths)

    per_finger = []
    categories = []

    for idx, cnt in enumerate(contours):
        x, y, w, h = cv2.boundingRect(cnt)
        aspect = h / max(w, 1)

        # ê¸¸ì´ êµ¬ë¶„
        if aspect < 1.2:
            length = "short"
        elif aspect < 1.6:
            length = "mid"
        else:
            length = "long"

        # í­ êµ¬ë¶„
        width_type = "narrow" if w < width_median else "wide"

        category = f"{length}-{width_type}"
        categories.append(category)

        per_finger.append({
            "finger": idx + 1,
            "x": int(x),
            "y": int(y),
            "width": int(w),
            "height": int(h),
            "aspect": float(aspect),
            "length": length,
            "width_type": width_type,
            "category": category,
        })

    # ì „ì²´ ì†ì˜ ëŒ€í‘œ length-wideë¥¼ ë‹¤ìˆ˜ê²°ë¡œ ì„ íƒ
    def majority(vs, default):
        if not vs:
            return default
        vals, counts = np.unique(vs, return_counts=True)
        return vals[np.argmax(counts)]

    length_major = majority([c.split("-")[0] for c in categories], "mid")
    width_major = majority([c.split("-")[1] for c in categories], "narrow")

    final_category = f"{length_major}-{width_major}"

    return per_finger, final_category



# ===========================================================
# 2) CSV ê¸°ë°˜ shape + design ì¶”ì²œ
# ===========================================================
def recommend_designs(len_wid: str, top_k: int = 3, allowed_designs=None):

    df = design_df.copy()
    df = df[df["len_wid"] == len_wid]

    if allowed_designs:
        df = df[df["design"].isin(allowed_designs)]

    if df.empty:
        return []

    df = df.sort_values("score_joint", ascending=False)
    rows = df.head(top_k)

    recos = []
    for _, row in rows.iterrows():
        recos.append({
            "shape": row["shape"],
            "design": row["design"],
            "score": float(row["score_joint"]),
        })
    return recos



# ===========================================================
# 3) PNG ë„¤ì¼íŒì„ ì† ì´ë¯¸ì§€ì— í•©ì„±
# ===========================================================
def apply_nail_png(base_img, mask, png_path):
    """
    base_img : numpy RGB
    mask     : 0/255 nail mask
    png_path : path to PNG
    """
    overlay = base_img.copy()

    # PNG ì½ê¸° (RGBA)
    nail_png = Image.open(png_path).convert("RGBA")
    nail_png = np.array(nail_png)

    # ì†í†± contour ì°¾ê¸°
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for cnt in contours:
        x, y, w, h = cv2.boundingRect(cnt)

        # -----------------------------
        # ğŸ”¥ ê¸¸ì´(ë†’ì´) ì—°ì¥ ë¹„ìœ¨
        # scale=1.6 â†’ 60% ê¸¸ê²Œ ë¶™ì„ (ë„¤ì¼íŒ ëŠë‚Œ)
        # ì›í•˜ë©´ 1.2~2.0ê¹Œì§€ ì¡°ì ˆ ê°€ëŠ¥
        # -----------------------------
        scale = 1.6
        H_new = int(h * scale)

        # PNGë¥¼ (í­=w, ë†’ì´=ì—°ì¥ëœ H_new) í¬ê¸°ë¡œ resize
        resized_png = cv2.resize(nail_png, (w, H_new))

        # RGB + ì•ŒíŒŒ ë¶„ë¦¬
        png_rgb = resized_png[:, :, :3]
        png_alpha = resized_png[:, :, 3] / 255.0

        # -----------------------------
        # ğŸ”¥ yì¢Œí‘œ ë³´ì • â†’ ê¸¸ì–´ì§„ ë¶€ë¶„ ìœ„ìª½ìœ¼ë¡œ ë¶™ê²Œ í•¨
        # -----------------------------
        y_new = max(0, y - (H_new - h))

        # ROI ì˜ì—­ ì„¤ì •
        roi = overlay[y_new:y_new + H_new, x:x + w]

        # ë²”ìœ„ ë²—ì–´ë‚˜ë©´ ì˜ˆì™¸ ì²˜ë¦¬
        if roi.shape[0] != H_new or roi.shape[1] != w:
            continue

        # -----------------------------
        # ğŸ”¥ ì•ŒíŒŒë¸”ë Œë”©
        # -----------------------------
        for c in range(3):
            roi[:, :, c] = (png_rgb[:, :, c] * png_alpha +
                            roi[:, :, c] * (1 - png_alpha))

        overlay[y_new:y_new + H_new, x:x + w] = roi

    return overlay




# ===========================================================
# 4) YOLO + SAM + ì¶”ì²œ + PNG í•©ì„± ì „ì²´ íŒŒì´í”„ë¼ì¸
# ===========================================================
def run_pipeline(pil_image, allowed_designs=None):

    image = np.array(pil_image.convert("RGB"))

    # ---------------- YOLO: ì†í†± bbox ----------------
    res = yolo_model.predict(image, conf=0.5, verbose=False)[0]
    if res.boxes is None or len(res.boxes) == 0:
        msg = "<p>âŒ ì†í†±ì„ ê°ì§€í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>"
        return pil_image, pil_image, msg, None

    boxes = res.boxes.xyxy.cpu().numpy()

    # YOLO ì‹œê°í™”
    yolo_vis_bgr = res.plot()
    yolo_vis_rgb = cv2.cvtColor(yolo_vis_bgr, cv2.COLOR_BGR2RGB)
    yolo_vis_pil = Image.fromarray(yolo_vis_rgb)

    # ---------------- SAM: ì†í†± ë¶„ë¦¬ ----------------
    predictor.set_image(image)
    masks = []

    for x1, y1, x2, y2 in boxes:
        box = np.array([[x1, y1, x2, y2]])
        mask, _, _ = predictor.predict(
            box=box,
            point_coords=None,
            point_labels=None,
            multimask_output=False,
        )
        masks.append(mask[0])

    final_mask = np.any(masks, axis=0).astype(np.uint8) * 255

    # SAM ë§ˆìŠ¤í¬ ì‹œê°í™”
    mask_vis = image.copy()
    blue = np.array([0, 0, 255], dtype=np.uint8)
    mask_region = final_mask == 255
    mask_vis[mask_region] = (
        0.6 * mask_vis[mask_region] + 0.4 * blue
    ).astype(np.uint8)
    mask_vis_pil = Image.fromarray(mask_vis)

    # ---------------- ì†í†± ê¸¸ì´/í­ ë¶„ì„ ----------------
    per_finger, final_category = analyze_shape_from_mask(final_mask)
    if final_category is None:
        msg = "<p>âŒ ë§ˆìŠ¤í¬ëŠ” ìƒì„±í–ˆìœ¼ë‚˜ contourê°€ ì—†ìŠµë‹ˆë‹¤.</p>"
        return yolo_vis_pil, mask_vis_pil, msg, None

    len_wid = final_category

    # ---------------- ì¶”ì²œ TOP3 ----------------
    recos = recommend_designs(len_wid, top_k=3, allowed_designs=allowed_designs)

    length, width = final_category.split("-")
    length_kor = {"short": "ì§§ì€", "mid": "ì¤‘ê°„ ê¸¸ì´", "long": "ê¸´"}
    width_kor = {"narrow": "ì¢ì€", "wide": "ë„“ì€"}

    html = f"<h3>ì† ì „ì²´ ìœ í˜•: {length_kor.get(length)} Â· {width_kor.get(width)}</h3>"
    html += f"<p>len_wid = <b>{len_wid}</b>, ê°ì§€ëœ ì†í†± = {len(per_finger)}ê°œ</p><ul>"
    for f in per_finger:
        html += f"<li>Finger {f['finger']}: {f['category']} (aspect={f['aspect']:.2f})</li>"
    html += "</ul>"

    # TOP3 ì¹´ë“œ
    html += "<h4>TOP 3 ë„¤ì¼íŒ + ë””ìì¸ ì¶”ì²œ</h4><div style='display:flex; gap:12px;'>"
    for i, r in enumerate(recos, start=1):
        html += f"""
        <div style="border:1px solid #ddd; border-radius:10px; padding:10px; min-width:150px;">
            <div style="font-weight:bold;">TOP {i}</div>
            <div>Tip Shape: <b>{r['shape']}</b></div>
            <div>Design: <b>{r['design']}</b></div>
            <div style="font-size:11px; color:#666;">Score: {r['score']:.3f}</div>
        </div>"""
    html += "</div>"

    # ---------------- TOP2 PNG ìë™ í•©ì„± ----------------
    final_overlay_pil = None

    if len(recos) >= 2:
        top2_shape = recos[1]["shape"]
        top2_design = recos[1]["design"]

        png_path = f"{PNG_DIR}/{top2_shape}_{top2_design}.png"

        try:
            overlay_img = apply_nail_png(image, final_mask, png_path)
            final_overlay_pil = Image.fromarray(overlay_img)
        except Exception as e:
            print("PNG í•©ì„± ì˜¤ë¥˜:", e)
            final_overlay_pil = None

    return yolo_vis_pil, mask_vis_pil, html, final_overlay_pil